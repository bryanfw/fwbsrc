%% LOADSQLXML     Load information from a Philips MRI .SQL.XML file
%
% [INFO] = LOADSQLXML(FILENAME)
%
%   FILENAME is a string containing a file prefix or full name of the 
%   .SQL.XML file, e.g. SURVEY_1 or SURVEY_1.SQL.XML data.
%
%   .SQL.XML files are generated by the vuSuperExport tool
%
%   INFO is a structure containing details from the .SQL.XML file
%
% [INFO] = LOADSQLXML([])
%
%   When the passed FILENAME is not provided or is an empty array or empty 
%   string.  The user chooses a file using UIGETFILE.


%% Revision History
% 2011.07.29    initial version - brianwelch

%% Function definition
function [info] = loadXMLREC(filename)

%% Allow user to select a file if input FILENAME is not provided or is empty
if nargin<1 | length(filename)==0,
    [fn, pn] = uigetfile( ...
        {'*.SQL.XML', '.SQL.XML files (*.SQL.XML)'; ...
         '*.*',   'All Files (*.*)'}, ...
         'Select SQLXML file');
    if fn~=0,
        filename = sprintf('%s%s',pn,fn);
    else
        disp('LOADSQLXML cancelled');
        return;
    end
end

%% Parse the filename.
% It may be the .SQL.XML filename or just the filename prefix
% Instead of REGEXP, use REGEXPI which igores case
toks = regexpi(filename,'^(.*?)(\.SQL\.XML)?$','tokens');
prefix = toks{1}{1};
info.sqlxml_filename = sprintf('%s.SQL.XML',prefix);

%% Open XML file and read all text
fid = fopen(info.sqlxml_filename,'r');
if fid~=-1,
    textblob = fread(fid,inf,'uint8=>char')';
    fclose(fid);
else
    error( sprintf('Cannot open %s for reading', info.sqlxml_filename) );
end

%% Turn textblob into separate tokens
% leading whitespace will not be returned
% ending carriage-return, newline (\r\n) will not be returned
% empty lines will not be returned
% individual tokens will be:
% 1. <immediately_closed_tag>contents</immediately_closed_tag>
% 2. <open_tag_with_no_immediate_close>
xml_tokens_as_cells = regexp(textblob,'\s*(<[^>]+>[^<]+<\/[^>]+>)|\s*(<[^>]+>)\s*','tokens');

%% Convert cell array of cell tokens into a cell array of strings
xml_tokens_as_strs = [xml_tokens_as_cells{:}];

%% First cell should contain series_roid inside an xml comment
info.series_roid = char( regexp(xml_tokens_as_strs{1},'series_\d*_\d*','match') );

%% Find start and stop points for SQL tags
detected_sql_open_close_tags = regexp(xml_tokens_as_strs,'<\/?[A-Z]*>','start');
found = find(1-cellfun('isempty',detected_sql_open_close_tags));
sql_group_opens = found(2:2:end);
sql_group_closes = found(3:2:end);

%% attribute regular expression tokens: 
% name
% value
% subattribute name(s)
% subattribute value(s)
attribute_name_regexp_token_pattern  = ' Name="([\w ]+)" ';
attribute_value_regexp_token_pattern = '>(.*)<';
attribute_subattribute_name_regexp_token_pattern = ' (\w+)=';
attribute_subattribute_value_regexp_token_pattern = '"([\w ]+)"';

%% Loop over SQL groups
for g=1:length(sql_group_opens),
    
    sql_group_name = char( regexp(xml_tokens_as_strs{sql_group_opens(g)},'\w*','match') ); 
    
    selected_xml_tokens_as_strs = [xml_tokens_as_cells{(sql_group_opens(g)+1):(sql_group_closes(g)-1)}];
    
    name_tokens_as_cells = regexp(selected_xml_tokens_as_strs,attribute_name_regexp_token_pattern,'tokens');
    value_tokens_as_cells = regexp(selected_xml_tokens_as_strs,attribute_value_regexp_token_pattern,'tokens');
    subattribute_name_tokens_as_cells = regexp(selected_xml_tokens_as_strs,attribute_subattribute_name_regexp_token_pattern,'tokens');
    subattribute_value_tokens_as_cells = regexp(selected_xml_tokens_as_strs,attribute_subattribute_value_regexp_token_pattern,'tokens');
    
    for k=1:length(name_tokens_as_cells),
        if ~isempty(value_tokens_as_cells{k}),
            
            parent_fieldname = char(regexprep(name_tokens_as_cells{k}{1},'\s*','_'));
            child_fieldnames = [subattribute_name_tokens_as_cells{k}{:}];
            child_values = [subattribute_value_tokens_as_cells{k}{:}];
        
            tmp_struct = cell2struct(child_values,child_fieldnames,2);
        
            if strcmpi(char(value_tokens_as_cells{k}{1}),'NULL'),

                info.(sql_group_name).(parent_fieldname) = char(value_tokens_as_cells{k}{1});
                
            else

                switch tmp_struct.Type,
                    case {'float','tinyint','smallint','int','numeric','numeric identity','real'}
                        info.(sql_group_name).(parent_fieldname) = str2num( char(value_tokens_as_cells{k}{1}) );
                    otherwise,
                        info.(sql_group_name).(parent_fieldname) = char(value_tokens_as_cells{k}{1});
                end

            end
            
        else
            % assign something empty
        end
    end

end

